<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Unicode CSV Viewer</title>
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Brahmi&family=Noto+Sans+Devanagari&family=Noto+Sans+Grantha&family=Noto+Sans+Lao+Looped&family=Noto+Sans+Myanmar&family=Noto+Sans+Oriya&family=Noto+Sans+Sinhala&family=Noto+Sans+Thai+Looped&family=Noto+Serif+Bengali&family=Noto+Serif+Khmer&display=swap');
		
		body {
			font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
			background:#111;
			color:#ccc;
			margin:0;
			padding:1.5rem;
		}

		a { color: #4BF; outline: none; text-decoration: underline; }

		h1 {
			font-size:1.4rem;
			margin-bottom:0.8rem;
		}

		code {
			background: #333;
			padding: 1px 3px;
			border-radius: 3px;
			letter-spacing: 0;
			font-size: .7em;
		}

		.controls {
			margin-bottom:1rem;
		}

		select {
			padding:0.25rem 0.5rem;
			font-size:0.95rem;
			background:#222;
			color:#eee;
			border:1px solid #555;
			border-radius:4px;
		}

		#status {
			margin-top:0.5rem;
			font-size:0.85rem;
			color:#ccc;
		}

		.converter {
			margin-top:1.2rem;
			display:flex;
			flex-wrap:wrap;
			gap:1rem;
		}

		.converter .panel {
			flex:1 1 300px;
			display:flex;
			flex-direction:column;
		}

		.converter label {
			margin-bottom:0.25rem;
			font-size:0.9rem;
		}

		textarea {
			width:100%;
			min-height:8rem;
			padding:0.5rem;
			margin:0.5rem;
			font-family: Arial, "Noto Sans Thai Looped", "Noto Sans Grantha", "Noto Sans Lao Looped", "Noto Sans Devanagari", "Noto Sans Oriya", "Noto Serif Khmer", "Noto Serif Bengali", "Noto Sans Brahmi", "Noto Sans Sinhala", "Noto Sans Myanmar", sans-serif;
			font-size:1.3em;
			background:#181818;
			color:#eee;
			border:1px solid #444;
			border-radius:4px;
			resize:vertical;
			resize:none;
		}

		textarea[readonly] {
			background:#141414;
		}

		.table-wrapper {
			margin-top:1rem;
			max-width:100%;
			overflow-x:auto;
		}

		table {
			border-collapse:collapse;
			min-width:600px;
			width:100%;
		}

		th, td {
			font-family: Arial, "Noto Sans Thai Looped", "Noto Sans Grantha", "Noto Sans Lao Looped", "Noto Sans Devanagari", "Noto Sans Oriya", "Noto Serif Khmer", "Noto Serif Bengali", "Noto Sans Brahmi", "Noto Sans Sinhala", "Noto Sans Myanmar", sans-serif;
			border:1px solid #444;
			padding:0.3rem 0.8rem;
			font-size:1.5rem;
			white-space:pre;
		}

		th {
			background:#222;
			position:sticky;
			top:0;
		}

		tbody tr:nth-child(even) {
			background:#1b1b1b;
		}

		tbody tr:nth-child(odd) {
			background:#151515;
		}
	</style>
</head>
<body>
	<h1>Unicode CSV Viewer</h1>

	<div class="controls">
		<label for="csvSelect">Choose CSV file: </label>
		<select id="csvSelect">
			<option value="">-- Select a CSV file --</option>
		</select>
		<div id="status"></div>
	</div>

	<div class="converter">
		<div class="panel">
			<label for="inputText">Input text</label>
			<textarea id="inputText" placeholder="Type or paste text to convert..."></textarea>
		</div>
		<div class="panel">
			<label for="outputText">Output text (converted)</label>
			<textarea id="outputText" readonly></textarea>
		</div>
	</div>	

	<div id="tableContainer" class="table-wrapper"></div>

	<p>To the <a href="https://github.com/paa-li/conv/">Github repo</a></p>

	<script>
		const csvFiles = [
			"beng.csv",
			"brah.csv",
			"deva.csv",
			"gran.csv",
			"khmr.csv",
			"laoo.csv",
			"mymr.csv",
			"orya.csv",
			"sinh.csv",
			"thai.csv"
		];

		const selectEl = document.getElementById("csvSelect");
		const statusEl = document.getElementById("status");
		const tableContainer = document.getElementById("tableContainer");
		const inputEl = document.getElementById("inputText");
		const outputEl = document.getElementById("outputText");

		let currentRules = [];

		function initSelect() {
			csvFiles.forEach(name => {
				const opt = document.createElement("option");
				opt.value = name;
				opt.textContent = name;
				selectEl.appendChild(opt);
			});
		}

		// --- Functions from your conversion logic style ---

		function decodeUnicodeEscapes(str) {
			if (!str) return "";
			return str.replace(/\\u([0-9a-fA-F]{4})/g, function (_m, hex) {
				return String.fromCharCode(parseInt(hex, 16));
			});
		}

		function cleanCell(cell) {
			cell = cell.trim();
			if (
				(cell.startsWith('"') && cell.endsWith('"')) ||
				(cell.startsWith("'") && cell.endsWith("'"))
			) {
				cell = cell.slice(1, -1);
			}
			return cell;
		}

		// Parse CSV into table rows + conversion rules (top -> bottom)
		function parseCsvForTableAndRules(text) {
			const lines = text.split(/\r?\n/);
			const rows = [];
			const rules = [];
			let rowNumber = 1;

			for (let i = 0; i < lines.length; i++) {
				let line = lines[i].trim();
				if (!line || line.startsWith("#")) continue;

				const parts = line.split(",");
				if (parts.length < 2) continue;

				let fromRaw = cleanCell(parts[0]);
				let toRaw = cleanCell(parts[1]);

				const from = decodeUnicodeEscapes(fromRaw);
				const to = decodeUnicodeEscapes(toRaw);

				// For conversion
				if (from !== "") {
					rules.push([from, to]); // applied top-to-bottom
				}

				// For table display
				rows.push({
					index: rowNumber++,
					raw1: fromRaw,
					raw2: toRaw,
					decoded1: from,
					decoded2: to
				});
			}

			return { rows, rules };
		}

		// Apply rules sequentially (top -> bottom)
		function applyRulesToText(text, rules) {
			let out = text;
			for (const [from, to] of rules) {
				if (!from) continue;
				// plain string replace, all occurrences
				out = out.split(from).join(to);
			}
			return out;
		}

		function updateOutput() {
			if (!currentRules || currentRules.length === 0) {
				outputEl.value = inputEl.value;
			} else {
				outputEl.value = applyRulesToText(inputEl.value, currentRules);
			}
		}

		inputEl.addEventListener("input", updateOutput);

		// --- Table rendering ---

		function renderTable(rows) {
			tableContainer.innerHTML = "";

			if (!rows.length) {
				tableContainer.textContent = "No data.";
				return;
			}

			const table = document.createElement("table");

			const thead = document.createElement("thead");
			const headerRow = document.createElement("tr");
			const headers = ["#", "Raw col 1", "Raw col 2", "Decoded col 1", "Decoded col 2"];

			headers.forEach(text => {
				const th = document.createElement("th");
				th.textContent = text;
				headerRow.appendChild(th);
			});
			thead.appendChild(headerRow);
			table.appendChild(thead);

			const tbody = document.createElement("tbody");
			rows.forEach(row => {
				const tr = document.createElement("tr");

				const tdIndex = document.createElement("td");
				tdIndex.textContent = row.index;
				tr.appendChild(tdIndex);

				// Raw col 1 with <code>
				const tdRaw1 = document.createElement("td");
				const code1 = document.createElement("code");
				code1.textContent = row.raw1;
				tdRaw1.appendChild(code1);
				tr.appendChild(tdRaw1);

				// Raw col 2 with <code>
				const tdRaw2 = document.createElement("td");
				const code2 = document.createElement("code");
				code2.textContent = row.raw2;
				tdRaw2.appendChild(code2);
				tr.appendChild(tdRaw2);

				const tdDec1 = document.createElement("td");
				tdDec1.textContent = row.decoded1;
				tr.appendChild(tdDec1);

				const tdDec2 = document.createElement("td");
				tdDec2.textContent = row.decoded2;
				tr.appendChild(tdDec2);

				tbody.appendChild(tr);
			});

			table.appendChild(tbody);
			tableContainer.appendChild(table);
		}

		// --- Loading CSV and hash behavior ---

		async function loadCsv(fileName) {
			if (!fileName) {
				tableContainer.innerHTML = "";
				statusEl.textContent = "";
				currentRules = [];
				updateOutput();
				return;
			}

			statusEl.textContent = `Loading ${fileName}...`;

			try {
				const response = await fetch(fileName);
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}`);
				}
				const text = await response.text();
				const parsed = parseCsvForTableAndRules(text);
				currentRules = parsed.rules;
				renderTable(parsed.rows);
				statusEl.textContent = `Loaded ${fileName} (${parsed.rows.length} rows).`;

				// Re-run conversion for existing input
				updateOutput();
			} catch (err) {
				tableContainer.innerHTML = "";
				statusEl.textContent = `Error loading ${fileName}: ${err.message}`;
				currentRules = [];
				updateOutput();
			}
		}

		function applyHashOnLoad() {
			const hash = window.location.hash;
			if (!hash || hash.length < 2) return;

			const fileName = decodeURIComponent(hash.slice(1));
			if (csvFiles.includes(fileName)) {
				selectEl.value = fileName;
				loadCsv(fileName);
			}
		}

		selectEl.addEventListener("change", () => {
			const fileName = selectEl.value;

			if (fileName) {
				window.location.hash = encodeURIComponent(fileName);
			} else {
				// clear hash if user chooses the empty option
				history.replaceState(null, "", window.location.pathname);
			}

			loadCsv(fileName);
		});

		// Init
		initSelect();
		applyHashOnLoad();
	</script>
</body>
</html>
